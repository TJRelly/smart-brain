{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRouteRegex = getRouteRegex;\nexports.getNamedRouteRegex = getNamedRouteRegex;\nexports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;\n\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\n\nvar _escapeRegexp = require(\"../../escape-regexp\");\n\nvar _removeTrailingSlash = require(\"./remove-trailing-slash\");\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`\n *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`\n */\n\n\nfunction parseParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  const repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\n\nfunction getParametrizedRoute(route) {\n  const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  return {\n    parameterizedRoute: segments.map(segment => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1));\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n      } else {\n        return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n      }\n    }).join(''),\n    groups\n  };\n}\n\nfunction getRouteRegex(normalizedRoute) {\n  const {\n    parameterizedRoute,\n    groups\n  } = getParametrizedRoute(normalizedRoute);\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups: groups\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\n\n\nfunction buildGetSafeRouteKey() {\n  let routeKeyCharCode = 97;\n  let routeKeyCharLength = 1;\n  return () => {\n    let routeKey = '';\n\n    for (let i = 0; i < routeKeyCharLength; i++) {\n      routeKey += String.fromCharCode(routeKeyCharCode);\n      routeKeyCharCode++;\n\n      if (routeKeyCharCode > 122) {\n        routeKeyCharLength++;\n        routeKeyCharCode = 97;\n      }\n    }\n\n    return routeKey;\n  };\n}\n\nfunction getNamedParametrizedRoute(route) {\n  const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys = {};\n  return {\n    namedParameterizedRoute: segments.map(segment => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1)); // replace any non-word characters since they can break\n        // the named regex\n\n        let cleanedKey = key.replace(/\\W/g, '');\n        let invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n\n        if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n          invalidKey = true;\n        }\n\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n      } else {\n        return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n      }\n    }).join(''),\n    routeKeys\n  };\n}\n\nfunction getNamedRouteRegex(normalizedRoute) {\n  const result = getNamedParametrizedRoute(normalizedRoute);\n  return _extends({}, getRouteRegex(normalizedRoute), {\n    namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n    routeKeys: result.routeKeys\n  });\n}\n\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  const {\n    parameterizedRoute\n  } = getParametrizedRoute(normalizedRoute);\n  const {\n    catchAll = true\n  } = options;\n\n  if (parameterizedRoute === '/') {\n    let catchAllRegex = catchAll ? '.*' : '';\n    return {\n      namedRegex: `^/${catchAllRegex}$`\n    };\n  }\n\n  const {\n    namedParameterizedRoute\n  } = getNamedParametrizedRoute(normalizedRoute);\n  let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n  return {\n    namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`\n  };\n}","map":{"version":3,"mappings":"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","names":["getRouteRegex","getNamedRouteRegex","getNamedMiddlewareRegex","parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","segments","removeTrailingSlash","split","groups","groupIndex","parameterizedRoute","map","segment","pos","escapeStringRegexp","join","normalizedRoute","re","RegExp","buildGetSafeRouteKey","routeKeyCharCode","routeKeyCharLength","routeKey","i","String","fromCharCode","getNamedParametrizedRoute","getSafeRouteKey","routeKeys","namedParameterizedRoute","cleanedKey","replace","invalidKey","length","isNaN","parseInt","result","_extends","namedRegex","options","catchAll","catchAllRegex","catchAllGroupedRegex"],"sources":["../../../../../../src/shared/lib/router/utils/route-regex.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}