{"ast":null,"code":"\"use client\";\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handleClientScriptLoad = handleClientScriptLoad;\nexports.initScriptLoader = initScriptLoader;\nexports.default = void 0;\n\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\n\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\n\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\n\nvar _object_without_properties_loose = require(\"@swc/helpers/lib/_object_without_properties_loose.js\").default;\n\nvar _reactDom = _interop_require_default(require(\"react-dom\"));\n\nvar _react = _interop_require_wildcard(require(\"react\"));\n\nvar _headManagerContext = require(\"../shared/lib/head-manager-context\");\n\nvar _headManager = require(\"./head-manager\");\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst ignoreProps = ['onLoad', 'onReady', 'dangerouslySetInnerHTML', 'children', 'onError', 'strategy'];\n\nconst loadScript = props => {\n  const {\n    src,\n    id,\n    onLoad = () => {},\n    onReady = null,\n    dangerouslySetInnerHTML,\n    children = '',\n    strategy = 'afterInteractive',\n    onError\n  } = props;\n  const cacheKey = id || src; // Script has already loaded\n\n  if (cacheKey && LoadCache.has(cacheKey)) {\n    return;\n  } // Contents of this script are already loading/loaded\n\n\n  if (ScriptCache.has(src)) {\n    LoadCache.add(cacheKey); // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n    // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n\n    ScriptCache.get(src).then(onLoad, onError);\n    return;\n  }\n  /** Execute after the script first loaded */\n\n\n  const afterLoad = () => {\n    // Run onReady for the first time after load event\n    if (onReady) {\n      onReady();\n    } // add cacheKey to LoadCache when load successfully\n\n\n    LoadCache.add(cacheKey);\n  };\n\n  const el = document.createElement('script');\n  const loadPromise = new Promise((resolve, reject) => {\n    el.addEventListener('load', function (e) {\n      resolve();\n\n      if (onLoad) {\n        onLoad.call(this, e);\n      }\n\n      afterLoad();\n    });\n    el.addEventListener('error', function (e) {\n      reject(e);\n    });\n  }).catch(function (e) {\n    if (onError) {\n      onError(e);\n    }\n  });\n\n  if (dangerouslySetInnerHTML) {\n    el.innerHTML = dangerouslySetInnerHTML.__html || '';\n    afterLoad();\n  } else if (children) {\n    el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n    afterLoad();\n  } else if (src) {\n    el.src = src; // do not add cacheKey into LoadCache for remote script here\n    // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n\n    ScriptCache.set(src, loadPromise);\n  }\n\n  for (const [k, value] of Object.entries(props)) {\n    if (value === undefined || ignoreProps.includes(k)) {\n      continue;\n    }\n\n    const attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();\n    el.setAttribute(attr, value);\n  }\n\n  if (strategy === 'worker') {\n    el.setAttribute('type', 'text/partytown');\n  }\n\n  el.setAttribute('data-nscript', strategy);\n  document.body.appendChild(el);\n};\n\nfunction handleClientScriptLoad(props) {\n  const {\n    strategy = 'afterInteractive'\n  } = props;\n\n  if (strategy === 'lazyOnload') {\n    window.addEventListener('load', () => {\n      (0, _requestIdleCallback).requestIdleCallback(() => loadScript(props));\n    });\n  } else {\n    loadScript(props);\n  }\n}\n\nfunction loadLazyScript(props) {\n  if (document.readyState === 'complete') {\n    (0, _requestIdleCallback).requestIdleCallback(() => loadScript(props));\n  } else {\n    window.addEventListener('load', () => {\n      (0, _requestIdleCallback).requestIdleCallback(() => loadScript(props));\n    });\n  }\n}\n\nfunction addBeforeInteractiveToCache() {\n  const scripts = [...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'), ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]')];\n  scripts.forEach(script => {\n    const cacheKey = script.id || script.getAttribute('src');\n    LoadCache.add(cacheKey);\n  });\n}\n\nfunction initScriptLoader(scriptLoaderItems) {\n  scriptLoaderItems.forEach(handleClientScriptLoad);\n  addBeforeInteractiveToCache();\n}\n\nfunction Script(props) {\n  const {\n    id,\n    src = '',\n    onLoad = () => {},\n    onReady = null,\n    strategy = 'afterInteractive',\n    onError\n  } = props,\n        restProps = _object_without_properties_loose(props, [\"id\", \"src\", \"onLoad\", \"onReady\", \"strategy\", \"onError\"]); // Context is available only during SSR\n\n\n  const {\n    updateScripts,\n    scripts,\n    getIsSsr,\n    appDir,\n    nonce\n  } = (0, _react).useContext(_headManagerContext.HeadManagerContext);\n  /**\n  * - First mount:\n  *   1. The useEffect for onReady executes\n  *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n  *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n  *   3. The useEffect for loadScript executes\n  *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n  *      Once the script is loaded, the onLoad and onReady will be called by then\n  *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n  *   5. The useEffect for onReady executes again\n  *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n  *   7. The useEffect for loadScript executes again\n  *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n  *\n  * - Second mount:\n  *   1. The useEffect for onReady executes\n  *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n  *      onReady is called, set hasOnReadyEffectCalled.current to true\n  *   3. The useEffect for loadScript executes\n  *   4. The script is already loaded, loadScript bails out\n  *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n  *   5. The useEffect for onReady executes again\n  *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n  *   7. The useEffect for loadScript executes again\n  *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n  */\n\n  const hasOnReadyEffectCalled = (0, _react).useRef(false);\n  (0, _react).useEffect(() => {\n    const cacheKey = id || src;\n\n    if (!hasOnReadyEffectCalled.current) {\n      // Run onReady if script has loaded before but component is re-mounted\n      if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n        onReady();\n      }\n\n      hasOnReadyEffectCalled.current = true;\n    }\n  }, [onReady, id, src]);\n  const hasLoadScriptEffectCalled = (0, _react).useRef(false);\n  (0, _react).useEffect(() => {\n    if (!hasLoadScriptEffectCalled.current) {\n      if (strategy === 'afterInteractive') {\n        loadScript(props);\n      } else if (strategy === 'lazyOnload') {\n        loadLazyScript(props);\n      }\n\n      hasLoadScriptEffectCalled.current = true;\n    }\n  }, [props, strategy]);\n\n  if (strategy === 'beforeInteractive' || strategy === 'worker') {\n    if (updateScripts) {\n      scripts[strategy] = (scripts[strategy] || []).concat([_extends({\n        id,\n        src,\n        onLoad,\n        onReady,\n        onError\n      }, restProps)]);\n      updateScripts(scripts);\n    } else if (getIsSsr && getIsSsr()) {\n      // Script has already loaded during SSR\n      LoadCache.add(id || src);\n    } else if (getIsSsr && !getIsSsr()) {\n      loadScript(props);\n    }\n  } // For the app directory, we need React Float to preload these scripts.\n\n\n  if (appDir) {\n    // Before interactive scripts need to be loaded by Next.js' runtime instead\n    // of native <script> tags, because they no longer have `defer`.\n    if (strategy === 'beforeInteractive') {\n      if (!src) {\n        // For inlined scripts, we put the content in `children`.\n        if (restProps.dangerouslySetInnerHTML) {\n          restProps.children = restProps.dangerouslySetInnerHTML.__html;\n          delete restProps.dangerouslySetInnerHTML;\n        }\n\n        return /*#__PURE__*/_react.default.createElement(\"script\", {\n          nonce: nonce,\n          dangerouslySetInnerHTML: {\n            __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([0, _extends({}, restProps)])})`\n          }\n        });\n      } // @ts-ignore\n\n\n      _reactDom.default.preload(src, restProps.integrity ? {\n        as: 'script',\n        integrity: restProps.integrity\n      } : {\n        as: 'script'\n      });\n\n      return /*#__PURE__*/_react.default.createElement(\"script\", {\n        nonce: nonce,\n        dangerouslySetInnerHTML: {\n          __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([src])})`\n        }\n      });\n    } else if (strategy === 'afterInteractive') {\n      if (src) {\n        // @ts-ignore\n        _reactDom.default.preload(src, restProps.integrity ? {\n          as: 'script',\n          integrity: restProps.integrity\n        } : {\n          as: 'script'\n        });\n      }\n    }\n  }\n\n  return null;\n}\n\nObject.defineProperty(Script, '__nextScript', {\n  value: true\n});\nvar _default = Script;\nexports.default = _default;\n\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"mappings":"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","names":["initScriptLoader","LoadCache","Set","ignoreProps","loadScript","props","id","onLoad","cacheKey","src","onReady","dangerouslySetInnerHTML","children","strategy","onError","add","ScriptCache","then","loadPromise","createElement","resolve","addEventListener","Promise","reject","call","afterLoad","el","catch","e","textContent","value","undefined","includes","setAttribute","k","document","appendChild","handleClientScriptLoad","window","requestIdleCallback","readyState","_requestIdleCallback","addBeforeInteractiveToCache","querySelectorAll","script","scriptLoaderItems","forEach","Script","restProps","updateScripts","scripts","getIsSsr","appDir","nonce","useEffect","_react","hasOnReadyEffectCalled","hasLoadScriptEffectCalled","loadLazyScript","__html","_extends","ReactDOM","preload","integrity","as","Object"],"sources":["../../../src/client/script.tsx"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}