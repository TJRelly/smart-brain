{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Tokenize input string.\n */\n\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n\n  while (i < str.length) {\n    var char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({\n        type: \"MODIFIER\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({\n        type: \"ESCAPED_CHAR\",\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({\n        type: \"OPEN\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({\n        type: \"CLOSE\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \":\") {\n      var name = \"\";\n      var j = i + 1;\n\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n\n        if ( // `0-9`\n        code >= 48 && code <= 57 || // `A-Z`\n        code >= 65 && code <= 90 || // `a-z`\n        code >= 97 && code <= 122 || // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(\"Missing parameter name at \" + i);\n      tokens.push({\n        type: \"NAME\",\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      var count = 1;\n      var pattern = \"\";\n      var j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(\"Capturing groups are not allowed at \" + j);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(\"Unbalanced pattern at \" + i);\n      if (!pattern) throw new TypeError(\"Missing pattern at \" + i);\n      tokens.push({\n        type: \"PATTERN\",\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n\n    tokens.push({\n      type: \"CHAR\",\n      index: i,\n      value: str[i++]\n    });\n  }\n\n  tokens.push({\n    type: \"END\",\n    index: i,\n    value: \"\"\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\n\n\nfunction parse(str, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n      prefixes = _a === void 0 ? \"./\" : _a;\n  var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = \"\";\n\n  var tryConsume = function (type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  var mustConsume = function (type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n        nextType = _a.type,\n        index = _a.index;\n    throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n  };\n\n  var consumeText = function () {\n    var result = \"\";\n    var value; // tslint:disable-next-line\n\n    while (value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\")) {\n      result += value;\n    }\n\n    return result;\n  };\n\n  while (i < tokens.length) {\n    var char = tryConsume(\"CHAR\");\n    var name = tryConsume(\"NAME\");\n    var pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      var prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    var value = char || tryConsume(\"ESCAPED_CHAR\");\n\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    var open = tryConsume(\"OPEN\");\n\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume(\"NAME\") || \"\";\n      var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n      var suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : \"\"),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\nfunction tokensToFunction(tokens, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var reFlags = flags(options);\n  var _a = options.encode,\n      encode = _a === void 0 ? function (x) {\n    return x;\n  } : _a,\n      _b = options.validate,\n      validate = _b === void 0 ? true : _b; // Compile all the tokens into regexps.\n\n  var matches = tokens.map(function (token) {\n    if (typeof token === \"object\") {\n      return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n    }\n  });\n  return function (data) {\n    var path = \"\";\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      var value = data ? data[token.name] : undefined;\n      var optional = token.modifier === \"?\" || token.modifier === \"*\";\n      var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          var segment = encode(value[j], token);\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        var segment = encode(String(value), token);\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n      var typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n    }\n\n    return path;\n  };\n}\n\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\n\nfunction match(str, options) {\n  var keys = [];\n  var re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\n\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\n\nfunction regexpToFunction(re, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.decode,\n      decode = _a === void 0 ? function (x) {\n    return x;\n  } : _a;\n  return function (pathname) {\n    var m = re.exec(pathname);\n    if (!m) return false;\n    var path = m[0],\n        index = m.index;\n    var params = Object.create(null);\n\n    var _loop_1 = function (i) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) return \"continue\";\n      var key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    };\n\n    for (var i = 1; i < m.length; i++) {\n      _loop_1(i);\n    }\n\n    return {\n      path: path,\n      index: index,\n      params: params\n    };\n  };\n}\n\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\n\n\nfunction flags(options) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path; // Use a negative lookahead to match only capturing groups.\n\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: \"\",\n        suffix: \"\",\n        modifier: \"\",\n        pattern: \"\"\n      });\n    }\n  }\n\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\n\n\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\n\n\nfunction tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.strict,\n      strict = _a === void 0 ? false : _a,\n      _b = options.start,\n      start = _b === void 0 ? true : _b,\n      _c = options.end,\n      end = _c === void 0 ? true : _c,\n      _d = options.encode,\n      encode = _d === void 0 ? function (x) {\n    return x;\n  } : _d;\n  var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n  var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n  var route = start ? \"^\" : \"\"; // Iterate over the tokens and create our regexp string.\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            var mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n          } else {\n            route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n          }\n        } else {\n          route += \"(\" + token.pattern + \")\" + token.modifier;\n        }\n      } else {\n        route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += delimiter + \"?\";\n    route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === \"string\" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : // tslint:disable-next-line\n    endToken === undefined;\n\n    if (!strict) {\n      route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n    }\n\n    if (!isEndDelimited) {\n      route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\n\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n\nexports.pathToRegexp = pathToRegexp;","map":{"version":3,"names":["Object","defineProperty","exports","value","lexer","str","tokens","i","length","char","push","type","index","name","j","code","charCodeAt","TypeError","count","pattern","parse","options","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","open","name_1","pattern_1","compile","tokensToFunction","reFlags","flags","encode","x","_b","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","test","String","typeOfMessage","match","keys","re","pathToRegexp","regexpToFunction","decode","pathname","m","exec","params","create","_loop_1","split","replace","sensitive","regexpToRegexp","groups","source","arrayToRegexp","paths","parts","join","stringToRegexp","tokensToRegexp","strict","start","_c","end","_d","endsWith","route","_i","tokens_1","mod","endToken","isEndDelimited"],"sources":["C:/Users/xxter/Documents/Coding/smart-brain/node_modules/next/dist/compiled/path-to-regexp/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script"}